"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.onCreateNode = exports.createSchemaCustomization = exports.createResolvers = exports.sourceNodes = exports.pluginOptionsSchema = void 0;
const gatsby_source_filesystem_1 = require("gatsby-source-filesystem");
const make_source_from_operation_1 = require("./make-source-from-operation");
const operations_1 = require("./operations");
function pluginOptionsSchema({ Joi }) {
    return Joi.object({
        storeUrl: Joi.string().required(),
        authToken: Joi.string().optional()
    });
}
exports.pluginOptionsSchema = pluginOptionsSchema;
async function sourceAllNodes(gatsbyApi, pluginOptions) {
    const { createProductsOperation, createRegionsOperation, createOrdersOperation, createCollectionsOperation } = (0, operations_1.createOperations)(pluginOptions, gatsbyApi);
    const operations = [
        createProductsOperation,
        createRegionsOperation,
        createCollectionsOperation
    ];
    // if auth token is provided then source orders
    if (pluginOptions.authToken) {
        operations.push(createOrdersOperation);
    }
    const sourceFromOperation = (0, make_source_from_operation_1.makeSourceFromOperation)(gatsbyApi);
    for (const op of operations) {
        await sourceFromOperation(op);
    }
}
const medusaNodeTypes = [
    "MedusaRegions",
    "MedusaProducts",
    "MedusaOrders",
    "MedusaCollections"
];
async function sourceUpdatedNodes(gatsbyApi, pluginOptions) {
    var _a, _b;
    const { incrementalProductsOperation, incrementalRegionsOperation, incrementalOrdersOperation, incrementalCollectionsOperation } = (0, operations_1.createOperations)(pluginOptions, gatsbyApi);
    const lastBuildTime = new Date((_b = (_a = gatsbyApi.store.getState().status.plugins) === null || _a === void 0 ? void 0 : _a[`gatsby-source-medusa`]) === null || _b === void 0 ? void 0 : _b[`lastBuildTime`]);
    for (const nodeType of medusaNodeTypes) {
        gatsbyApi
            .getNodesByType(nodeType)
            .forEach((node) => gatsbyApi.actions.touchNode(node));
    }
    const operations = [
        incrementalProductsOperation(lastBuildTime),
        incrementalRegionsOperation(lastBuildTime),
        incrementalCollectionsOperation(lastBuildTime)
    ];
    if (pluginOptions.authToken) {
        operations.push(incrementalOrdersOperation(lastBuildTime));
    }
    const sourceFromOperation = (0, make_source_from_operation_1.makeSourceFromOperation)(gatsbyApi);
    for (const op of operations) {
        await sourceFromOperation(op);
    }
}
async function sourceNodes(gatsbyApi, pluginOptions) {
    var _a;
    const pluginStatus = (_a = gatsbyApi.store.getState().status.plugins) === null || _a === void 0 ? void 0 : _a[`gatsby-source-medusa`];
    const lastBuildTime = pluginStatus === null || pluginStatus === void 0 ? void 0 : pluginStatus[`lastBuildTime`];
    if (lastBuildTime !== undefined) {
        gatsbyApi.reporter.info(`Cache is warm, but incremental builds are currently not supported. Running a clean build.`);
        await sourceAllNodes(gatsbyApi, pluginOptions);
    }
    else {
        gatsbyApi.reporter.info(`Cache is cold, running a clean build.`);
        await sourceAllNodes(gatsbyApi, pluginOptions);
    }
    gatsbyApi.reporter.info(`Finished sourcing nodes, caching last build time`);
    gatsbyApi.actions.setPluginStatus(pluginStatus !== undefined
        ? Object.assign(Object.assign({}, pluginStatus), { [`lastBuildTime`]: Date.now() }) : {
        [`lastBuildTime`]: Date.now()
    });
}
exports.sourceNodes = sourceNodes;
function createResolvers({ createResolvers }) {
    const resolvers = {
        MedusaProducts: {
            images: {
                type: ["MedusaImages"],
                resolve: async (source, _args, context, _info) => {
                    const { entries } = await context.nodeModel.findAll({
                        query: {
                            filter: { parent: { id: { eq: source.id } } }
                        },
                        type: "MedusaImages"
                    });
                    return entries;
                }
            }
        }
    };
    createResolvers(resolvers);
}
exports.createResolvers = createResolvers;
async function createSchemaCustomization({ actions: { createTypes } }) {
    createTypes(`
    type MedusaProducts implements Node {
      thumbnail: File @link(from: "fields.localThumbnail")
    }

    type MedusaImages implements Node {
      image: File @link(from: "fields.localImage")
    }
  `);
}
exports.createSchemaCustomization = createSchemaCustomization;
async function onCreateNode({ actions: { createNode, createNodeField }, cache, createNodeId, node, store, reporter }) {
    if (node.internal.type === `MedusaProducts`) {
        if (node.thumbnail !== null) {
            let thumbnailNode = await (0, gatsby_source_filesystem_1.createRemoteFileNode)({
                url: `${node.thumbnail}`,
                parentNodeId: node.id,
                createNode,
                createNodeId,
                cache,
                store,
                reporter
            });
            if (thumbnailNode) {
                createNodeField({
                    node,
                    name: `localThumbnail`,
                    value: thumbnailNode.id
                });
            }
        }
    }
    if (node.internal.type === `MedusaImages`) {
        let imageNode = await (0, gatsby_source_filesystem_1.createRemoteFileNode)({
            url: `${node.url}`,
            parentNodeId: node.id,
            createNode,
            createNodeId,
            cache,
            store,
            reporter
        });
        if (imageNode) {
            createNodeField({
                node,
                name: `localImage`,
                value: imageNode.id
            });
        }
    }
}
exports.onCreateNode = onCreateNode;
//# sourceMappingURL=gatsby-node.js.map