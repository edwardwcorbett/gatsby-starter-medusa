"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var lodash_1 = __importDefault(require("lodash"));
var medusa_interfaces_1 = require("medusa-interfaces");
var medusa_core_utils_1 = require("medusa-core-utils");
var discount_rule_1 = require("../models/discount-rule");
var cart_1 = require("../types/cart");
var orders_1 = require("../types/orders");
/**
 * A service that calculates total and subtotals for orders, carts etc..
 * @implements {BaseService}
 */
var TotalsService = /** @class */ (function (_super) {
    __extends(TotalsService, _super);
    function TotalsService(_a) {
        var taxProviderService = _a.taxProviderService, taxCalculationStrategy = _a.taxCalculationStrategy;
        var _this = _super.call(this) || this;
        _this.taxProviderService_ = taxProviderService;
        _this.taxCalculationStrategy_ = taxCalculationStrategy;
        return _this;
    }
    /**
     * Calculates subtotal of a given cart or order.
     * @param cartOrOrder - object to calculate total for
     * @param options - options to calculate by
     * @return the calculated subtotal
     */
    TotalsService.prototype.getTotal = function (cartOrOrder, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var subtotal, taxTotal, discountTotal, giftCardTotal, shippingTotal;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        subtotal = this.getSubtotal(cartOrOrder);
                        return [4 /*yield*/, this.getTaxTotal(cartOrOrder, options.force_taxes)];
                    case 1:
                        taxTotal = (_a.sent()) || 0;
                        discountTotal = this.getDiscountTotal(cartOrOrder);
                        giftCardTotal = this.getGiftCardTotal(cartOrOrder);
                        shippingTotal = this.getShippingTotal(cartOrOrder);
                        return [2 /*return*/, subtotal + taxTotal + shippingTotal - discountTotal - giftCardTotal];
                }
            });
        });
    };
    /**
     * Gets the total payments made on an order
     * @param order - the order to calculate paid amount for
     * @return the total paid amount
     */
    TotalsService.prototype.getPaidTotal = function (order) {
        var _a;
        var total = (_a = order.payments) === null || _a === void 0 ? void 0 : _a.reduce(function (acc, next) {
            acc += next.amount;
            return acc;
        }, 0);
        return total;
    };
    /**
     * The total paid for swaps. May be negative in case of negative swap
     * difference.
     * @param order - the order to calculate swap total for
     * @return the swap total
     */
    TotalsService.prototype.getSwapTotal = function (order) {
        var e_1, _a;
        var swapTotal = 0;
        if (order.swaps && order.swaps.length) {
            try {
                for (var _b = __values(order.swaps), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var s = _c.value;
                    swapTotal = swapTotal + s.difference_due;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        return swapTotal;
    };
    /**
     * Gets the totals breakdown for a shipping method. Fetches tax lines if not
     * already provided.
     * @param shippingMethod - the shipping method to get totals breakdown for.
     * @param cartOrOrder - the cart or order to use as context for the breakdown
     * @param opts - options for what should be included
     * @returns An object that breaks down the totals for the shipping method
     */
    TotalsService.prototype.getShippingMethodTotals = function (shippingMethod, cartOrOrder, opts) {
        if (opts === void 0) { opts = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var calculationContext, totals, taxLines, orderLines, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        calculationContext = this.getCalculationContext(cartOrOrder, {
                            exclude_shipping: true,
                        });
                        calculationContext.shipping_methods = [shippingMethod];
                        totals = {
                            price: shippingMethod.price,
                            original_total: shippingMethod.price,
                            total: shippingMethod.price,
                            original_tax_total: 0,
                            tax_total: 0,
                            tax_lines: shippingMethod.tax_lines || [],
                        };
                        if (!opts.include_tax) return [3 /*break*/, 7];
                        if (!((0, orders_1.isOrder)(cartOrOrder) && cartOrOrder.tax_rate !== null)) return [3 /*break*/, 1];
                        totals.original_tax_total = Math.round(totals.original_tax_total * (cartOrOrder.tax_rate / 100));
                        totals.tax_total = Math.round(totals.original_tax_total * (cartOrOrder.tax_rate / 100));
                        return [3 /*break*/, 5];
                    case 1:
                        taxLines = void 0;
                        if (!(opts.use_tax_lines || (0, orders_1.isOrder)(cartOrOrder))) return [3 /*break*/, 2];
                        if (typeof shippingMethod.tax_lines === "undefined") {
                            throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.UNEXPECTED_STATE, "Tax Lines must be joined on shipping method to calculate taxes");
                        }
                        taxLines = shippingMethod.tax_lines;
                        return [3 /*break*/, 4];
                    case 2: return [4 /*yield*/, this.taxProviderService_.getTaxLines(cartOrOrder.items, calculationContext)];
                    case 3:
                        orderLines = _b.sent();
                        console.log(orderLines);
                        taxLines = orderLines.filter(function (ol) {
                            if ("shipping_method_id" in ol) {
                                return ol.shipping_method_id === shippingMethod.id;
                            }
                            return false;
                        });
                        _b.label = 4;
                    case 4:
                        totals.tax_lines = taxLines;
                        _b.label = 5;
                    case 5:
                        if (!(totals.tax_lines.length > 0)) return [3 /*break*/, 7];
                        _a = totals;
                        return [4 /*yield*/, this.taxCalculationStrategy_.calculate([], totals.tax_lines, calculationContext)];
                    case 6:
                        _a.original_tax_total =
                            _b.sent();
                        totals.tax_total = totals.original_tax_total;
                        totals.original_total += totals.original_tax_total;
                        totals.total += totals.tax_total;
                        _b.label = 7;
                    case 7:
                        if (cartOrOrder.discounts) {
                            if (cartOrOrder.discounts.some(function (d) { return d.rule.type === "free_shipping"; })) {
                                totals.total = 0;
                                totals.tax_total = 0;
                            }
                        }
                        return [2 /*return*/, totals];
                }
            });
        });
    };
    /**
     * Calculates subtotal of a given cart or order.
     * @param cartOrOrder - cart or order to calculate subtotal for
     * @param opts - options
     * @return the calculated subtotal
     */
    TotalsService.prototype.getSubtotal = function (cartOrOrder, opts) {
        if (opts === void 0) { opts = {}; }
        var subtotal = 0;
        if (!cartOrOrder.items) {
            return subtotal;
        }
        cartOrOrder.items.map(function (item) {
            if (opts.excludeNonDiscounts) {
                if (item.allow_discounts) {
                    subtotal += item.unit_price * item.quantity;
                }
            }
            else {
                subtotal += item.unit_price * item.quantity;
            }
        });
        return this.rounded(subtotal);
    };
    /**
     * Calculates shipping total
     * @param cartOrOrder - cart or order to calculate subtotal for
     * @return shipping total
     */
    TotalsService.prototype.getShippingTotal = function (cartOrOrder) {
        var shipping_methods = cartOrOrder.shipping_methods;
        return shipping_methods.reduce(function (acc, next) {
            return acc + next.price;
        }, 0);
    };
    /**
     * Calculates tax total
     * Currently based on the Danish tax system
     * @param cartOrOrder - cart or order to calculate tax total for
     * @param forceTaxes - whether taxes should be calculated regardless
     *   of region settings
     * @return tax total
     */
    TotalsService.prototype.getTaxTotal = function (cartOrOrder, forceTaxes) {
        if (forceTaxes === void 0) { forceTaxes = false; }
        return __awaiter(this, void 0, void 0, function () {
            var calculationContext, taxLines, taxLinesJoined, shippingTaxLines, subtotal, shippingTotal, discountTotal, giftCardTotal, returnTaxLines, toReturn;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if ((0, cart_1.isCart)(cartOrOrder) &&
                            !forceTaxes &&
                            !cartOrOrder.region.automatic_taxes) {
                            return [2 /*return*/, null];
                        }
                        calculationContext = this.getCalculationContext(cartOrOrder);
                        if (!(0, orders_1.isOrder)(cartOrOrder)) return [3 /*break*/, 1];
                        taxLinesJoined = cartOrOrder.items.every(function (i) { return typeof i.tax_lines !== "undefined"; });
                        if (!taxLinesJoined) {
                            throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.UNEXPECTED_STATE, "Order tax calculations must have tax lines joined on line items");
                        }
                        if (cartOrOrder.tax_rate === null) {
                            taxLines = cartOrOrder.items.flatMap(function (li) { return li.tax_lines; });
                            shippingTaxLines = cartOrOrder.shipping_methods.flatMap(function (sm) { return sm.tax_lines; });
                            taxLines = taxLines.concat(shippingTaxLines);
                        }
                        else {
                            subtotal = this.getSubtotal(cartOrOrder);
                            shippingTotal = this.getShippingTotal(cartOrOrder);
                            discountTotal = this.getDiscountTotal(cartOrOrder);
                            giftCardTotal = this.getGiftCardTotal(cartOrOrder);
                            return [2 /*return*/, this.rounded((subtotal - discountTotal - giftCardTotal + shippingTotal) *
                                    (cartOrOrder.tax_rate / 100))];
                        }
                        return [3 /*break*/, 3];
                    case 1: return [4 /*yield*/, this.taxProviderService_.getTaxLines(cartOrOrder.items, calculationContext)];
                    case 2:
                        taxLines = _a.sent();
                        if (cartOrOrder.type === "swap") {
                            returnTaxLines = cartOrOrder.items.flatMap(function (i) {
                                if (i.is_return) {
                                    if (typeof i.tax_lines === "undefined") {
                                        throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.UNEXPECTED_STATE, "Return Line Items must join tax lines");
                                    }
                                    return i.tax_lines;
                                }
                                return [];
                            });
                            taxLines = taxLines.concat(returnTaxLines);
                        }
                        _a.label = 3;
                    case 3: return [4 /*yield*/, this.taxCalculationStrategy_.calculate(cartOrOrder.items, taxLines, calculationContext)];
                    case 4:
                        toReturn = _a.sent();
                        return [2 /*return*/, this.rounded(toReturn)];
                }
            });
        });
    };
    /**
     * Gets a map of discounts and gift cards that apply to line items in an
     * order. The function calculates the amount of a discount or gift card that
     * applies to a specific line item.
     * @param orderOrCart - the order or cart to get an allocation map for
     * @param options - controls what should be included in allocation map
     * @return the allocation map for the line items in the cart or order.
     */
    TotalsService.prototype.getAllocationMap = function (orderOrCart, options) {
        var e_2, _a, e_3, _b;
        if (options === void 0) { options = {}; }
        var allocationMap = {};
        if (!options.exclude_discounts) {
            var lineDiscounts = [];
            var discount = orderOrCart.discounts.find(function (_a) {
                var rule = _a.rule;
                return rule.type !== "free_shipping";
            });
            if (discount) {
                lineDiscounts = this.getLineDiscounts(orderOrCart, discount);
            }
            try {
                for (var lineDiscounts_1 = __values(lineDiscounts), lineDiscounts_1_1 = lineDiscounts_1.next(); !lineDiscounts_1_1.done; lineDiscounts_1_1 = lineDiscounts_1.next()) {
                    var ld = lineDiscounts_1_1.value;
                    if (allocationMap[ld.item.id]) {
                        allocationMap[ld.item.id].discount = {
                            amount: ld.amount,
                            unit_amount: ld.amount / ld.item.quantity,
                        };
                    }
                    else {
                        allocationMap[ld.item.id] = {
                            discount: {
                                amount: ld.amount,
                                unit_amount: ld.amount / ld.item.quantity,
                            },
                        };
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (lineDiscounts_1_1 && !lineDiscounts_1_1.done && (_a = lineDiscounts_1.return)) _a.call(lineDiscounts_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
        if (!options.exclude_gift_cards) {
            var lineGiftCards = [];
            if (orderOrCart.gift_cards && orderOrCart.gift_cards.length) {
                var subtotal = this.getSubtotal(orderOrCart);
                var giftCardTotal = this.getGiftCardTotal(orderOrCart);
                // If the fixed discount exceeds the subtotal we should
                // calculate a 100% discount
                var nominator = Math.min(giftCardTotal, subtotal);
                var percentage_1 = nominator / subtotal;
                lineGiftCards = orderOrCart.items.map(function (l) {
                    return {
                        item: l,
                        amount: l.unit_price * l.quantity * percentage_1,
                    };
                });
            }
            try {
                for (var lineGiftCards_1 = __values(lineGiftCards), lineGiftCards_1_1 = lineGiftCards_1.next(); !lineGiftCards_1_1.done; lineGiftCards_1_1 = lineGiftCards_1.next()) {
                    var lgc = lineGiftCards_1_1.value;
                    if (allocationMap[lgc.item.id]) {
                        allocationMap[lgc.item.id].gift_card = {
                            amount: lgc.amount,
                            unit_amount: lgc.amount / lgc.item.quantity,
                        };
                    }
                    else {
                        allocationMap[lgc.item.id] = {
                            discount: {
                                amount: lgc.amount,
                                unit_amount: lgc.amount / lgc.item.quantity,
                            },
                        };
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (lineGiftCards_1_1 && !lineGiftCards_1_1.done && (_b = lineGiftCards_1.return)) _b.call(lineGiftCards_1);
                }
                finally { if (e_3) throw e_3.error; }
            }
        }
        return allocationMap;
    };
    /**
     * Gets the total refund amount for an order.
     * @param order - the order to get total refund amount for.
     * @return the total refunded amount for an order.
     */
    TotalsService.prototype.getRefundedTotal = function (order) {
        if (!order.refunds) {
            return 0;
        }
        var total = order.refunds.reduce(function (acc, next) { return acc + next.amount; }, 0);
        return this.rounded(total);
    };
    /**
     * The amount that can be refunded for a given line item.
     * @param order - order to use as context for the calculation
     * @param lineItem - the line item to calculate the refund amount for.
     * @return the line item refund amount.
     */
    TotalsService.prototype.getLineItemRefund = function (order, lineItem) {
        var _this = this;
        var _a, _b;
        var allocationMap = this.getAllocationMap(order);
        var discountAmount = (((_b = (_a = allocationMap[lineItem.id]) === null || _a === void 0 ? void 0 : _a.discount) === null || _b === void 0 ? void 0 : _b.unit_amount) || 0) *
            lineItem.quantity;
        var lineSubtotal = lineItem.unit_price * lineItem.quantity - discountAmount;
        /*
         * Used for backcompat with old tax system
         */
        if (order.tax_rate !== null) {
            var taxRate = order.tax_rate / 100;
            return this.rounded(lineSubtotal * (1 + taxRate));
        }
        /*
         * New tax system uses the tax lines registerd on the line items
         */
        if (typeof lineItem.tax_lines === "undefined") {
            throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.UNEXPECTED_STATE, "Tax calculation did not receive tax_lines");
        }
        var taxTotal = lineItem.tax_lines.reduce(function (acc, next) {
            var taxRate = next.rate / 100;
            return acc + _this.rounded(lineSubtotal * taxRate);
        }, 0);
        return lineSubtotal + taxTotal;
    };
    /**
     * Calculates refund total of line items.
     * If any of the items to return have been discounted, we need to
     * apply the discount again before refunding them.
     * @param order - cart or order to calculate subtotal for
     * @param lineItems - the line items to calculate refund total for
     * @return the calculated subtotal
     */
    TotalsService.prototype.getRefundTotal = function (order, lineItems) {
        var e_4, _a, e_5, _b;
        var _this = this;
        var itemIds = order.items.map(function (i) { return i.id; });
        // in case we swap a swap, we need to include swap items
        if (order.swaps && order.swaps.length) {
            try {
                for (var _c = __values(order.swaps), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var s = _d.value;
                    var swapItemIds = s.additional_items.map(function (el) { return el.id; });
                    itemIds = __spreadArray(__spreadArray([], __read(itemIds), false), __read(swapItemIds), false);
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_4) throw e_4.error; }
            }
        }
        if (order.claims && order.claims.length) {
            try {
                for (var _e = __values(order.claims), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var c = _f.value;
                    var claimItemIds = c.additional_items.map(function (el) { return el.id; });
                    itemIds = __spreadArray(__spreadArray([], __read(itemIds), false), __read(claimItemIds), false);
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                }
                finally { if (e_5) throw e_5.error; }
            }
        }
        var refunds = lineItems.map(function (i) {
            if (!itemIds.includes(i.id)) {
                throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.INVALID_DATA, "Line item does not exist on order");
            }
            return _this.getLineItemRefund(order, i);
        });
        return this.rounded(refunds.reduce(function (acc, next) { return acc + next; }, 0));
    };
    /**
     * Calculates either fixed or percentage discount of a variant
     * @param lineItem - id of line item
     * @param variant - id of variant in line item
     * @param variantPrice - price of the variant based on region
     * @param value - discount value
     * @param discountType - the type of discount (fixed or percentage)
     * @return triples of lineitem, variant and applied discount
     */
    TotalsService.prototype.calculateDiscount_ = function (lineItem, variant, variantPrice, value, discountType) {
        if (!lineItem.allow_discounts) {
            return {
                lineItem: lineItem,
                variant: variant,
                amount: 0,
            };
        }
        if (discountType === discount_rule_1.DiscountRuleType.PERCENTAGE) {
            return {
                lineItem: lineItem,
                variant: variant,
                amount: ((variantPrice * lineItem.quantity) / 100) * value,
            };
        }
        else {
            return {
                lineItem: lineItem,
                variant: variant,
                amount: value >= variantPrice * lineItem.quantity
                    ? variantPrice * lineItem.quantity
                    : value * lineItem.quantity,
            };
        }
    };
    /**
     * If the rule of a discount has allocation="item", then we need
     * to calculate discount on each item in the cart. Furthermore, we need to
     * make sure to only apply the discount on valid variants. And finally we
     * return ether an array of percentages discounts or fixed discounts
     * alongside the variant on which the discount was applied.
     * @param discount - the discount to which we do the calculation
     * @param cart - the cart to calculate discounts for
     * @return array of triples of lineitem, variant and applied discount
     */
    TotalsService.prototype.getAllocationItemDiscounts = function (discount, cart) {
        var e_6, _a;
        var _this = this;
        var _b;
        var discounts = [];
        var _loop_1 = function (item) {
            if (((_b = discount.rule.valid_for) === null || _b === void 0 ? void 0 : _b.length) > 0) {
                discount.rule.valid_for.map(function (_a) {
                    var id = _a.id;
                    if (item.variant.product_id === id) {
                        discounts.push(_this.calculateDiscount_(item, item.variant.id, item.unit_price, discount.rule.value, discount.rule.type));
                    }
                });
            }
        };
        try {
            for (var _c = __values(cart.items), _d = _c.next(); !_d.done; _d = _c.next()) {
                var item = _d.value;
                _loop_1(item);
            }
        }
        catch (e_6_1) { e_6 = { error: e_6_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_6) throw e_6.error; }
        }
        return discounts;
    };
    /**
     * Returns the discount amount allocated to the line items of an order.
     * @param cartOrOrder - the cart or order to get line discount allocations for
     * @param discount - the discount to use as context for the calculation
     * @return the allocations that the discount has on the items in the cart or
     *   order
     */
    TotalsService.prototype.getLineDiscounts = function (cartOrOrder, discount) {
        var e_7, _a, e_8, _b;
        var subtotal = this.getSubtotal(cartOrOrder, {
            excludeNonDiscounts: true,
        });
        var merged = __spreadArray([], __read(cartOrOrder.items), false);
        // merge items from order with items from order swaps
        if ("swaps" in cartOrOrder && cartOrOrder.swaps.length) {
            try {
                for (var _c = __values(cartOrOrder.swaps), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var s = _d.value;
                    merged = __spreadArray(__spreadArray([], __read(merged), false), __read(s.additional_items), false);
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_7) throw e_7.error; }
            }
        }
        if ("claims" in cartOrOrder && cartOrOrder.claims.length) {
            try {
                for (var _e = __values(cartOrOrder.claims), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var c = _f.value;
                    merged = __spreadArray(__spreadArray([], __read(merged), false), __read(c.additional_items), false);
                }
            }
            catch (e_8_1) { e_8 = { error: e_8_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                }
                finally { if (e_8) throw e_8.error; }
            }
        }
        var _g = discount.rule, type = _g.type, allocation = _g.allocation, value = _g.value;
        if (allocation === "total") {
            var percentage_2 = 0;
            if (type === "percentage") {
                percentage_2 = value / 100;
            }
            else if (type === "fixed") {
                // If the fixed discount exceeds the subtotal we should
                // calculate a 100% discount
                var nominator = Math.min(value, subtotal);
                percentage_2 = nominator / subtotal;
            }
            return merged.map(function (item) {
                var lineTotal = item.unit_price * item.quantity;
                return {
                    item: item,
                    amount: item.allow_discounts ? lineTotal * percentage_2 : 0,
                };
            });
        }
        else if (allocation === "item") {
            var allocationDiscounts_1 = this.getAllocationItemDiscounts(discount, cartOrOrder);
            return merged.map(function (item) {
                var discounted = allocationDiscounts_1.find(function (a) { return a.lineItem.id === item.id; });
                return {
                    item: item,
                    amount: discounted ? discounted.amount : 0,
                };
            });
        }
        return merged.map(function (i) { return ({ item: i, amount: 0 }); });
    };
    /**
     * Breaks down the totals related to a line item; these are the subtotal, the
     * amount of discount applied to the line item, the amount of a gift card
     * applied to a line item and the amount of tax applied to a line item.
     * @param lineItem - the line item to calculate totals for
     * @param cartOrOrder - the cart or order to use as context for the calculation
     * @param options - the options to evaluate the line item totals for
     * @returns the breakdown of the line item totals
     */
    TotalsService.prototype.getLineItemTotals = function (lineItem, cartOrOrder, options) {
        var _a, _b;
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var calculationContext, lineItemAllocation, subtotal, gift_card_total, discount_total, lineItemTotals, taxLines, orderLines, _c, _d;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        calculationContext = this.getCalculationContext(cartOrOrder, {
                            exclude_shipping: true,
                        });
                        lineItemAllocation = calculationContext.allocation_map[lineItem.id] || {};
                        subtotal = lineItem.unit_price * lineItem.quantity;
                        gift_card_total = ((_a = lineItemAllocation.gift_card) === null || _a === void 0 ? void 0 : _a.amount) || 0;
                        discount_total = (((_b = lineItemAllocation.discount) === null || _b === void 0 ? void 0 : _b.unit_amount) || 0) * lineItem.quantity;
                        lineItemTotals = {
                            unit_price: lineItem.unit_price,
                            quantity: lineItem.quantity,
                            subtotal: subtotal,
                            gift_card_total: gift_card_total,
                            discount_total: discount_total,
                            total: subtotal - discount_total,
                            original_total: subtotal,
                            original_tax_total: 0,
                            tax_total: 0,
                            tax_lines: lineItem.tax_lines || [],
                        };
                        if (!options.include_tax) return [3 /*break*/, 6];
                        if (!((0, orders_1.isOrder)(cartOrOrder) && cartOrOrder.tax_rate !== null)) return [3 /*break*/, 1];
                        lineItemTotals.original_tax_total =
                            subtotal * (cartOrOrder.tax_rate / 100);
                        lineItemTotals.tax_total =
                            (subtotal - discount_total) * (cartOrOrder.tax_rate / 100);
                        lineItemTotals.total += lineItemTotals.tax_total;
                        lineItemTotals.original_total += lineItemTotals.original_tax_total;
                        return [3 /*break*/, 6];
                    case 1:
                        taxLines = void 0;
                        if (!(options.use_tax_lines || (0, orders_1.isOrder)(cartOrOrder))) return [3 /*break*/, 2];
                        if (typeof lineItem.tax_lines === "undefined") {
                            throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.UNEXPECTED_STATE, "Tax Lines must be joined on items to calculate taxes");
                        }
                        taxLines = lineItem.tax_lines;
                        return [3 /*break*/, 5];
                    case 2:
                        if (!lineItem.is_return) return [3 /*break*/, 3];
                        if (typeof lineItem.tax_lines === "undefined") {
                            throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.UNEXPECTED_STATE, "Return Line Items must join tax lines");
                        }
                        taxLines = lineItem.tax_lines;
                        return [3 /*break*/, 5];
                    case 3: return [4 /*yield*/, this.taxProviderService_.getTaxLines(cartOrOrder.items, calculationContext)];
                    case 4:
                        orderLines = _e.sent();
                        taxLines = orderLines.filter(function (ol) {
                            if ("item_id" in ol) {
                                return ol.item_id === lineItem.id;
                            }
                            return false;
                        });
                        _e.label = 5;
                    case 5:
                        lineItemTotals.tax_lines = taxLines;
                        _e.label = 6;
                    case 6:
                        if (!(lineItemTotals.tax_lines.length > 0)) return [3 /*break*/, 9];
                        _c = lineItemTotals;
                        return [4 /*yield*/, this.taxCalculationStrategy_.calculate([lineItem], lineItemTotals.tax_lines, calculationContext)];
                    case 7:
                        _c.tax_total = _e.sent();
                        lineItemTotals.total += lineItemTotals.tax_total;
                        calculationContext.allocation_map = {}; // Don't account for discounts
                        _d = lineItemTotals;
                        return [4 /*yield*/, this.taxCalculationStrategy_.calculate([lineItem], lineItemTotals.tax_lines, calculationContext)];
                    case 8:
                        _d.original_tax_total =
                            _e.sent();
                        lineItemTotals.original_total += lineItemTotals.original_tax_total;
                        _e.label = 9;
                    case 9: return [2 /*return*/, lineItemTotals];
                }
            });
        });
    };
    /**
     * Gets a total for a line item. The total can take gift cards, discounts and
     * taxes into account. This can be controlled through the options.
     * @param lineItem - the line item to calculate a total for
     * @param cartOrOrder - the cart or order to use as context for the calculation
     * @param options - the options to use for the calculation
     * @returns the line item total
     */
    TotalsService.prototype.getLineItemTotal = function (lineItem, cartOrOrder, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var lineItemTotals, toReturn;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getLineItemTotals(lineItem, cartOrOrder, {
                            include_tax: options.include_tax,
                        })];
                    case 1:
                        lineItemTotals = _a.sent();
                        toReturn = lineItemTotals.subtotal;
                        if (!options.exclude_discounts) {
                            toReturn += lineItemTotals.discount_total;
                        }
                        if (!options.exclude_gift_cards) {
                            toReturn += lineItemTotals.gift_card_total;
                        }
                        if (options.include_tax) {
                            toReturn += lineItemTotals.tax_total;
                        }
                        return [2 /*return*/, toReturn];
                }
            });
        });
    };
    /**
     * Gets the gift card amount on a cart or order.
     * @param cartOrOrder - the cart or order to get gift card amount for
     * @return the gift card amount applied to the cart or order
     */
    TotalsService.prototype.getGiftCardTotal = function (cartOrOrder) {
        var giftCardable = this.getSubtotal(cartOrOrder) - this.getDiscountTotal(cartOrOrder);
        if ("gift_card_transactions" in cartOrOrder) {
            return cartOrOrder.gift_card_transactions.reduce(function (acc, next) { return acc + next.amount; }, 0);
        }
        if (!cartOrOrder.gift_cards || !cartOrOrder.gift_cards.length) {
            return 0;
        }
        var toReturn = cartOrOrder.gift_cards.reduce(function (acc, next) { return acc + next.balance; }, 0);
        return Math.min(giftCardable, toReturn);
    };
    /**
     * Calculates the total discount amount for each of the different supported
     * discount types. If discounts aren't present or invalid returns 0.
     * @param cartOrOrder - the cart or order to calculate discounts for
     * @return the total discounts amount
     */
    TotalsService.prototype.getDiscountTotal = function (cartOrOrder) {
        var subtotal = this.getSubtotal(cartOrOrder, {
            excludeNonDiscounts: true,
        });
        if (!cartOrOrder.discounts || !cartOrOrder.discounts.length) {
            return 0;
        }
        // we only support having free shipping and one other discount, so first
        // find the discount, which is not free shipping.
        var discount = cartOrOrder.discounts.find(function (_a) {
            var rule = _a.rule;
            return rule.type !== "free_shipping";
        });
        if (!discount) {
            return 0;
        }
        var _a = discount.rule, type = _a.type, allocation = _a.allocation, value = _a.value;
        var toReturn = 0;
        if (type === "percentage" && allocation === "total") {
            toReturn = (subtotal / 100) * value;
        }
        else if (type === "percentage" && allocation === "item") {
            var itemPercentageDiscounts = this.getAllocationItemDiscounts(discount, cartOrOrder);
            toReturn = lodash_1.default.sumBy(itemPercentageDiscounts, function (d) { return d.amount; });
        }
        else if (type === "fixed" && allocation === "total") {
            toReturn = value;
        }
        else if (type === "fixed" && allocation === "item") {
            var itemFixedDiscounts = this.getAllocationItemDiscounts(discount, cartOrOrder);
            toReturn = lodash_1.default.sumBy(itemFixedDiscounts, function (d) { return d.amount; });
        }
        if (subtotal < 0) {
            return this.rounded(Math.max(subtotal, toReturn));
        }
        return this.rounded(Math.min(subtotal, toReturn));
    };
    /**
     * Prepares the calculation context for a tax total calculation.
     * @param cartOrOrder - the cart or order to get the calculation context for
     * @param options - options to gather context by
     * @return the tax calculation context
     */
    TotalsService.prototype.getCalculationContext = function (cartOrOrder, options) {
        var _a;
        if (options === void 0) { options = {}; }
        var allocationMap = this.getAllocationMap(cartOrOrder, {
            exclude_gift_cards: options.exclude_gift_cards,
            exclude_discounts: options.exclude_discounts,
        });
        var shippingMethods = [];
        // Default to include shipping methods
        if (!options.exclude_shipping) {
            shippingMethods = cartOrOrder.shipping_methods || [];
        }
        return {
            shipping_address: cartOrOrder.shipping_address,
            shipping_methods: shippingMethods,
            customer: cartOrOrder.customer,
            region: cartOrOrder.region,
            is_return: (_a = options.is_return) !== null && _a !== void 0 ? _a : false,
            allocation_map: allocationMap,
        };
    };
    /**
     * Rounds a number using Math.round.
     * @param value - the value to round
     * @return the rounded value
     */
    TotalsService.prototype.rounded = function (value) {
        return Math.round(value);
    };
    return TotalsService;
}(medusa_interfaces_1.BaseService));
exports.default = TotalsService;
//# sourceMappingURL=totals.js.map