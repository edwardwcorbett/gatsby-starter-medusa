import { EntityManager } from "typeorm";
import { BaseService } from "medusa-interfaces";
import { ShippingMethodRepository } from "../repositories/shipping-method";
import { CartRepository } from "../repositories/cart";
import { AddressRepository } from "../repositories/address";
import { PaymentSessionRepository } from "../repositories/payment-session";
import { Address } from "../models/address";
import { Cart } from "../models/cart";
import { Customer } from "../models/customer";
import { LineItem } from "../models/line-item";
import { ShippingMethod } from "../models/shipping-method";
import { CustomShippingOption } from "../models/custom-shipping-option";
import { TotalField, FindConfig } from "../types/common";
import { FilterableCartProps, LineItemUpdate, CartUpdateProps, CartCreateProps } from "../types/cart";
import EventBusService from "./event-bus";
import ProductVariantService from "./product-variant";
import ProductService from "./product";
import RegionService from "./region";
import LineItemService from "./line-item";
import PaymentProviderService from "./payment-provider";
import ShippingOptionService from "./shipping-option";
import CustomerService from "./customer";
import TaxProviderService from "./tax-provider";
import DiscountService from "./discount";
import GiftCardService from "./gift-card";
import TotalsService from "./totals";
import InventoryService from "./inventory";
import CustomShippingOptionService from "./custom-shipping-option";
declare type CartConstructorProps = {
    manager: EntityManager;
    cartRepository: typeof CartRepository;
    shippingMethodRepository: typeof ShippingMethodRepository;
    addressRepository: typeof AddressRepository;
    paymentSessionRepository: typeof PaymentSessionRepository;
    eventBusService: EventBusService;
    taxProviderService: TaxProviderService;
    paymentProviderService: PaymentProviderService;
    productService: ProductService;
    productVariantService: ProductVariantService;
    regionService: RegionService;
    lineItemService: LineItemService;
    shippingOptionService: ShippingOptionService;
    customerService: CustomerService;
    discountService: DiscountService;
    giftCardService: GiftCardService;
    totalsService: TotalsService;
    inventoryService: InventoryService;
    customShippingOptionService: CustomShippingOptionService;
};
declare type TotalsConfig = {
    force_taxes?: boolean;
};
declare class CartService extends BaseService {
    static Events: {
        CUSTOMER_UPDATED: string;
        CREATED: string;
        UPDATED: string;
    };
    private manager_;
    private shippingMethodRepository_;
    private cartRepository_;
    private eventBus_;
    private productVariantService_;
    private productService_;
    private regionService_;
    private lineItemService_;
    private paymentProviderService_;
    private customerService_;
    private shippingOptionService_;
    private discountService_;
    private giftCardService_;
    private taxProviderService_;
    private totalsService_;
    private addressRepository_;
    private paymentSessionRepository_;
    private inventoryService_;
    private customShippingOptionService_;
    constructor({ manager, cartRepository, shippingMethodRepository, eventBusService, paymentProviderService, productService, productVariantService, taxProviderService, regionService, lineItemService, shippingOptionService, customerService, discountService, giftCardService, totalsService, addressRepository, paymentSessionRepository, inventoryService, customShippingOptionService, }: CartConstructorProps);
    withTransaction(transactionManager: EntityManager): CartService;
    transformQueryForTotals_(config: FindConfig<Cart>): FindConfig<Cart> & {
        totalsToSelect: TotalField[];
    };
    decorateTotals_(cart: Cart, totalsToSelect: TotalField[], options?: TotalsConfig): Promise<Cart>;
    /**
     * @param selector - the query object for find
     * @param config - config object
     * @return the result of the find operation
     */
    list(selector: FilterableCartProps, config?: FindConfig<Cart>): Promise<Cart[]>;
    /**
     * Gets a cart by id.
     * @param cartId - the id of the cart to get.
     * @param options - the options to get a cart
     * @param totalsConfig - configuration for retrieval of totals
     * @return the cart document.
     */
    retrieve(cartId: string, options?: FindConfig<Cart>, totalsConfig?: TotalsConfig): Promise<Cart>;
    /**
     * Creates a cart.
     * @param data - the data to create the cart with
     * @return the result of the create operation
     */
    create(data: CartCreateProps): Promise<Cart>;
    /**
     * Removes a line item from the cart.
     * @param cartId - the id of the cart that we will remove from
     * @param lineItemId - the line item to remove.
     * @return the result of the update operation
     */
    removeLineItem(cartId: string, lineItemId: string): Promise<Cart>;
    /**
     * Checks if a given line item has a shipping method that can fulfill it.
     * Returns true if all products in the cart can be fulfilled with the current
     * shipping methods.
     * @param shippingMethods - the set of shipping methods to check from
     * @param lineItem - the line item
     * @return boolean representing wheter shipping method is validated
     */
    validateLineItemShipping_(shippingMethods: ShippingMethod[], lineItem: LineItem): boolean;
    /**
     * Adds a line item to the cart.
     * @param cartId - the id of the cart that we will add to
     * @param lineItem - the line item to add.
     * @return the result of the update operation
     */
    addLineItem(cartId: string, lineItem: LineItem): Promise<Cart>;
    /**
     * Updates a cart's existing line item.
     * @param cartId - the id of the cart to update
     * @param lineItemId - the id of the line item to update.
     * @param lineItemUpdate - the line item to update. Must include an id field.
     * @return the result of the update operation
     */
    updateLineItem(cartId: string, lineItemId: string, lineItemUpdate: LineItemUpdate): Promise<Cart>;
    /**
     * Ensures shipping total on cart is correct in regards to a potential free
     * shipping discount
     * If a free shipping is present, we set shipping methods price to 0
     * if a free shipping was present, we set shipping methods to original amount
     * @param cart - the the cart to adjust free shipping for
     * @param shouldAdd - flag to indicate, if we should add or remove
     * @return void
     */
    adjustFreeShipping_(cart: Cart, shouldAdd: boolean): Promise<void>;
    update(cartId: string, update: CartUpdateProps): Promise<Cart>;
    /**
     * Sets the customer id of a cart
     * @param cart - the cart to add email to
     * @param customerId - the customer to add to cart
     * @return the result of the update operation
     */
    updateCustomerId_(cart: Cart, customerId: string): Promise<void>;
    /**
     * Creates or fetches a user based on an email.
     * @param email - the email to use
     * @return the resultign customer object
     */
    createOrFetchUserFromEmail_(email: string): Promise<Customer>;
    /**
     * Updates the cart's billing address.
     * @param cart - the cart to update
     * @param addressOrId - the value to set the billing address to
     * @param addrRepo - the repository to use for address updates
     * @return the result of the update operation
     */
    updateBillingAddress_(cart: Cart, addressOrId: Partial<Address> | string, addrRepo: AddressRepository): Promise<void>;
    /**
     * Updates the cart's shipping address.
     * @param cart - the cart to update
     * @param addressOrId - the value to set the shipping address to
     * @param addrRepo - the repository to use for address updates
     * @return the result of the update operation
     */
    updateShippingAddress_(cart: Cart, addressOrId: Partial<Address> | string, addrRepo: AddressRepository): Promise<void>;
    applyGiftCard_(cart: Cart, code: string): Promise<void>;
    /**
     * Updates the cart's discounts.
     * If discount besides free shipping is already applied, this
     * will be overwritten
     * Throws if discount regions does not include the cart region
     * @param cart - the cart to update
     * @param discountCode - the discount code
     * @return the result of the update operation
     */
    applyDiscount(cart: Cart, discountCode: string): Promise<void>;
    /**
     * Removes a discount based on a discount code.
     * @param cartId - the id of the cart to remove from
     * @param discountCode - the discount code to remove
     * @return the resulting cart
     */
    removeDiscount(cartId: string, discountCode: string): Promise<Cart>;
    /**
     * Updates the currently selected payment session.
     * @param cartId - the id of the cart to update the payment session for
     * @param update - the data to update the payment session with
     * @return the resulting cart
     */
    updatePaymentSession(cartId: string, update: object): Promise<Cart>;
    /**
     * Authorizes a payment for a cart.
     * Will authorize with chosen payment provider. This will return
     * a payment object, that we will use to update our cart payment with.
     * Additionally, if the payment does not require more or fails, we will
     * set the payment on the cart.
     * @param cartId - the id of the cart to authorize payment for
     * @param context - object containing whatever is relevant for
     *    authorizing the payment with the payment provider. As an example,
     *    this could be IP address or similar for fraud handling.
     * @return the resulting cart
     */
    authorizePayment(cartId: string, context?: Record<string, any>): Promise<Cart>;
    /**
     * Sets a payment method for a cart.
     * @param cartId - the id of the cart to add payment method to
     * @param providerId - the id of the provider to be set to the cart
     * @return result of update operation
     */
    setPaymentSession(cartId: string, providerId: string): Promise<Cart>;
    /**
     * Creates, updates and sets payment sessions associated with the cart. The
     * first time the method is called payment sessions will be created for each
     * provider. Additional calls will ensure that payment sessions have correct
     * amounts, currencies, etc. as well as make sure to filter payment sessions
     * that are not available for the cart's region.
     * @param cartOrCartId - the id of the cart to set payment session for
     * @return the result of the update operation.
     */
    setPaymentSessions(cartOrCartId: Cart | string): Promise<Cart>;
    /**
     * Removes a payment session from the cart.
     * @param cartId - the id of the cart to remove from
     * @param providerId - the id of the provider whoose payment session
     *    should be removed.
     * @return the resulting cart.
     */
    deletePaymentSession(cartId: string, providerId: string): Promise<Cart>;
    /**
     * Refreshes a payment session on a cart
     * @param cartId - the id of the cart to remove from
     * @param providerId - the id of the provider whoose payment session
     *    should be removed.
     * @return {Promise<Cart>} the resulting cart.
     */
    refreshPaymentSession(cartId: string, providerId: string): Promise<Cart>;
    /**
     * Adds the shipping method to the list of shipping methods associated with
     * the cart. Shipping Methods are the ways that an order is shipped, whereas a
     * Shipping Option is a possible way to ship an order. Shipping Methods may
     * also have additional details in the data field such as an id for a package
     * shop.
     * @param cartId - the id of the cart to add shipping method to
     * @param optionId - id of shipping option to add as valid method
     * @param data - the fulmillment data for the method
     * @return the result of the update operation
     */
    addShippingMethod(cartId: string, optionId: string, data?: Record<string, any>): Promise<Cart>;
    /**
     * Finds the cart's custom shipping options based on the passed option id.
     * throws if custom options is not empty and no shipping option corresponds to optionId
     * @param cartCustomShippingOptions - the cart's custom shipping options
     * @param optionId - id of the normal or custom shipping option to find in the cartCustomShippingOptions
     * @return custom shipping option
     */
    findCustomShippingOption(cartCustomShippingOptions: CustomShippingOption[], optionId: string): CustomShippingOption | undefined;
    /**
     * Set's the region of a cart.
     * @param cart - the cart to set region on
     * @param regionId - the id of the region to set the region to
     * @param countryCode - the country code to set the country to
     * @return the result of the update operation
     */
    setRegion_(cart: Cart, regionId: string, countryCode: string | null): Promise<void>;
    /**
     * Deletes a cart from the database. Completed carts cannot be deleted.
     * @param cartId - the id of the cart to delete
     * @return the deleted cart or undefined if the cart was not found.
     */
    delete(cartId: string): Promise<string>;
    /**
     * Dedicated method to set metadata for a cart.
     * To ensure that plugins does not overwrite each
     * others metadata fields, setMetadata is provided.
     * @param cartId - the cart to apply metadata to.
     * @param key - key for metadata field
     * @param value - value for metadata field.
     * @return resolves to the updated result.
     */
    setMetadata(cartId: string, key: string, value: string | number): Promise<Cart>;
    createTaxLines(id: string): Promise<Cart>;
    /**
     * Dedicated method to delete metadata for a cart.
     * @param cartId - the cart to delete metadata from.
     * @param key - key for metadata field
     * @return resolves to the updated result.
     */
    deleteMetadata(cartId: string, key: string): Promise<Cart>;
}
export default CartService;
