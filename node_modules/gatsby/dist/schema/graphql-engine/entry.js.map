{"version":3,"sources":["../../../src/schema/graphql-engine/entry.ts"],"names":["tracerReadyPromise","process","env","GATSBY_OPEN_TRACING_CONFIG_FILE","GraphQLEngine","constructor","dbPath","getRunner","_doGetRunner","store","dispatch","actions","createTypes","SCHEMA_SNAPSHOT","type","payload","flattenedPlugins","pluginName","Object","keys","gatsbyNodes","name","resolve","gatsbyWorkers","fullMetadataBuild","GraphQLRunner","runnerPromise","ready","runQuery","query","context","opts","engineContext","requestId","uuid","v4","doRunQuery","queryName","parentSpan","undefined","gettingRunnerActivity","graphqlRunner","reporter","phantomActivity","start","end","result","waitingForJobsCreatedByCurrentRequestActivity","findPageByPath","pathName","state","pages","get","getNode","values","iterateNodesByType"],"mappings":"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","sourcesContent":["// \"engines-fs-provider\" must be first import, as it sets up global\n// fs and this need to happen before anything else tries to import fs\nimport \"../../utils/engines-fs-provider\"\n\nimport { ExecutionResult, Source } from \"graphql\"\nimport { uuid } from \"gatsby-core-utils\"\nimport { build } from \"../index\"\nimport { setupLmdbStore } from \"../../datastore/lmdb/lmdb-datastore\"\nimport { store } from \"../../redux\"\nimport { actions } from \"../../redux/actions\"\nimport reporter from \"gatsby-cli/lib/reporter\"\nimport { GraphQLRunner, IQueryOptions } from \"../../query/graphql-runner\"\nimport { waitJobsByRequest } from \"../../utils/wait-until-jobs-complete\"\nimport { setGatsbyPluginCache } from \"../../utils/require-gatsby-plugin\"\nimport apiRunnerNode from \"../../utils/api-runner-node\"\nimport type { IGatsbyPage, IGatsbyState } from \"../../redux/types\"\nimport { findPageByPath } from \"../../utils/find-page-by-path\"\nimport { runWithEngineContext } from \"../../utils/engine-context\"\nimport { getDataStore } from \"../../datastore\"\nimport {\n  gatsbyNodes,\n  gatsbyWorkers,\n  flattenedPlugins,\n  // @ts-ignore\n} from \".cache/query-engine-plugins\"\nimport { initTracer } from \"../../utils/tracer\"\n\ntype MaybePhantomActivity =\n  | ReturnType<typeof reporter.phantomActivity>\n  | undefined\n\nconst tracerReadyPromise = initTracer(\n  process.env.GATSBY_OPEN_TRACING_CONFIG_FILE ?? ``\n)\n\nexport class GraphQLEngine {\n  // private schema: GraphQLSchema\n  private runnerPromise?: Promise<GraphQLRunner>\n\n  constructor({ dbPath }: { dbPath: string }) {\n    setupLmdbStore({ dbPath })\n    // start initializing runner ASAP\n    this.getRunner()\n  }\n\n  private async _doGetRunner(): Promise<GraphQLRunner> {\n    await tracerReadyPromise\n    // @ts-ignore SCHEMA_SNAPSHOT is being \"inlined\" by bundler\n    store.dispatch(actions.createTypes(SCHEMA_SNAPSHOT))\n\n    // TODO: FLATTENED_PLUGINS needs to be merged with plugin options from gatsby-config\n    //  (as there might be non-serializable options, i.e. functions)\n    store.dispatch({\n      type: `SET_SITE_FLATTENED_PLUGINS`,\n      payload: flattenedPlugins,\n    })\n\n    for (const pluginName of Object.keys(gatsbyNodes)) {\n      setGatsbyPluginCache(\n        { name: pluginName, resolve: `` },\n        `gatsby-node`,\n        gatsbyNodes[pluginName]\n      )\n    }\n    for (const pluginName of Object.keys(gatsbyWorkers)) {\n      setGatsbyPluginCache(\n        { name: pluginName, resolve: `` },\n        `gatsby-worker`,\n        gatsbyWorkers[pluginName]\n      )\n    }\n    if (_CFLAGS_.GATSBY_MAJOR === `4`) {\n      await apiRunnerNode(`onPluginInit`)\n    } else {\n      await apiRunnerNode(`unstable_onPluginInit`)\n    }\n    await apiRunnerNode(`createSchemaCustomization`)\n\n    // Build runs\n    // Note: skipping inference metadata because we rely on schema snapshot\n    await build({ fullMetadataBuild: false })\n\n    return new GraphQLRunner(store)\n  }\n\n  private async getRunner(): Promise<GraphQLRunner> {\n    if (!this.runnerPromise) {\n      this.runnerPromise = this._doGetRunner()\n    }\n    return this.runnerPromise\n  }\n\n  public async ready(): Promise<void> {\n    // We don't want to expose internal runner freely. We do expose `runQuery` function already.\n    // The way internal runner works can change, so we should not make it a public API.\n    // Here we just want to expose way to await it being ready\n    await this.getRunner()\n  }\n\n  public async runQuery(\n    query: string | Source,\n    context: Record<string, any> = {},\n    opts?: IQueryOptions\n  ): Promise<ExecutionResult> {\n    const engineContext = {\n      requestId: uuid.v4(),\n    }\n\n    const doRunQuery = async (): Promise<ExecutionResult> => {\n      if (!opts) {\n        opts = {\n          queryName: `GraphQL Engine query`,\n          parentSpan: undefined,\n        }\n      }\n\n      let gettingRunnerActivity: MaybePhantomActivity\n      let graphqlRunner: GraphQLRunner\n      try {\n        if (opts.parentSpan) {\n          gettingRunnerActivity = reporter.phantomActivity(\n            `Waiting for graphql runner to init`,\n            {\n              parentSpan: opts.parentSpan,\n            }\n          )\n          gettingRunnerActivity.start()\n        }\n        graphqlRunner = await this.getRunner()\n      } finally {\n        if (gettingRunnerActivity) {\n          gettingRunnerActivity.end()\n        }\n      }\n\n      // graphqlRunner creates it's own Span as long as we pass `parentSpan`\n      const result = await graphqlRunner.query(query, context, opts)\n\n      let waitingForJobsCreatedByCurrentRequestActivity: MaybePhantomActivity\n      try {\n        if (opts.parentSpan) {\n          waitingForJobsCreatedByCurrentRequestActivity =\n            reporter.phantomActivity(`Waiting for jobs to finish`, {\n              parentSpan: opts.parentSpan,\n            })\n          waitingForJobsCreatedByCurrentRequestActivity.start()\n        }\n        await waitJobsByRequest(engineContext.requestId)\n      } finally {\n        if (waitingForJobsCreatedByCurrentRequestActivity) {\n          waitingForJobsCreatedByCurrentRequestActivity.end()\n        }\n      }\n      return result\n    }\n\n    try {\n      return await runWithEngineContext(engineContext, doRunQuery)\n    } finally {\n      // Reset job-to-request mapping\n      store.dispatch({\n        type: `CLEAR_JOB_V2_CONTEXT`,\n        payload: engineContext,\n      })\n    }\n  }\n\n  public findPageByPath(pathName: string): IGatsbyPage | undefined {\n    // adapter so `findPageByPath` use SitePage nodes in datastore\n    // instead of `pages` redux slice\n    const state = {\n      pages: {\n        get(pathName: string): IGatsbyPage | undefined {\n          return getDataStore().getNode(`SitePage ${pathName}`) as\n            | IGatsbyPage\n            | undefined\n        },\n        values(): Iterable<IGatsbyPage> {\n          return getDataStore().iterateNodesByType(\n            `SitePage`\n          ) as Iterable<IGatsbyPage>\n        },\n      },\n    } as unknown as IGatsbyState\n\n    return findPageByPath(state, pathName, false)\n  }\n}\n\nexport default { GraphQLEngine }\n"],"file":"entry.js"}